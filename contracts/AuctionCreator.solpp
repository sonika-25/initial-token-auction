pragma soliditypp 0.8.0;

contract AuctionCreator{
   event auctionCreated (uint256 auctionId, uint256 time);
   event bidPlaced (uint256 auctionId, uint256 bidId, uint256 time);
   event TokensSold (uint256 auctionId, uint256 time);
   event viteReturned (uint256 auctionId, uint256 time);
   enum AuctionStatus {
      ComingSoon,
      Ongoing,
      Over
   }
   struct Auction {
      uint256 auctionId;
      uint256 amount;
      uint256 endDate;
      address [] buyers;
      address payable seller;
      vitetoken assetId;
      AuctionStatus status;
   }
   struct Bid {
      uint256 bidId;
      address payable buyer;
      uint256 amount;
      uint256 unitPrice;
   }
   Auction [] public auctions;
   mapping (uint256 => Bid[]) public bidsPerAuction;
   constructor () payable {}

   function startAuction(vitetoken _token, uint256 _endDate, uint256 _amount) public {
      require(msg.token == _token, "send same token");
      require(balance(_token)>=_amount , "token not sufficient");
      Auction memory auction;
      auction.auctionId = auctions.length;
      auction.amount = _amount;
      auction.endDate = _endDate;
      auction.seller = payable(msg.sender);
      auction.assetId = _token;
      auction.status = AuctionStatus.Ongoing;
      auctions.push (auction);
      emit auctionCreated (auctions.length, block.timestamp);
   }

   function placeBid (uint256 _auctionId, uint256 _bidAmount, uint256 _unitPrice) public payable withinDuration(_auctionId) {
      require (msg.value == _bidAmount, "_bidAmount too high");
      bidsPerAuction[_auctionId].push (Bid(
         bidsPerAuction[_auctionId].length,
         payable (msg.sender),
         _bidAmount,
         _unitPrice
      ));
      emit bidPlaced (_auctionId, bidsPerAuction[_auctionId].length, block.timestamp);
   }

   function ResolveAuction (uint256 _auctionId) public payable {
      require (block.timestamp > auctions[_auctionId].endDate , "Auction Ongoing");
      uint256 len = bidsPerAuction[_auctionId].length;
      //Bid [] memory aBids = bidsPerAuction[_auctionId];
      if (len>1){
         for (uint i =0; i< len; i++){
            for (uint j=0; j< (len-i-1); j++){
               if (bidsPerAuction[_auctionId][j].amount > bidsPerAuction[_auctionId][j+1].amount){
                  Bid memory highBid = bidsPerAuction[_auctionId][j];
                  bidsPerAuction[_auctionId][j]= bidsPerAuction[_auctionId][j+1];
                  bidsPerAuction[_auctionId][j+1]=highBid;
               }
            }
         }
      }
      //bidsPerAuction[_auctionId] = aBids;
      while (auctions[_auctionId].amount >0){
         uint256 currBidId;
         Bid memory currBid = bidsPerAuction[_auctionId][currBidId];
         address payable to = currBid.buyer;
         uint256 sellamount = currBid.amount/ currBid.unitPrice;
         vitetoken asset = auctions[_auctionId].assetId;
         if (auctions[_auctionId].amount >= sellamount){
            to.transfer(asset, sellamount);
            auctions[_auctionId].seller.transfer("tti_5649544520544f4b454e6e40",currBid.amount);
            auctions[_auctionId].buyers.push(to);
         }
         if (auctions[_auctionId].amount <sellamount) {
            to.transfer(asset, auctions[_auctionId].amount);
            uint returnVal = currBid.amount - ((auctions[_auctionId].amount) * (currBid.unitPrice));
            to.transfer("tti_5649544520544f4b454e6e40", returnVal);
            auctions[_auctionId].seller.transfer("tti_5649544520544f4b454e6e40", currBid.amount-returnVal);
            auctions[_auctionId].buyers.push(to);
         }
         auctions[_auctionId].amount -=sellamount;
         currBidId++;
      }
      emit TokensSold (_auctionId, block.timestamp);

      uint256 buyersLength = auctions[_auctionId].buyers.length;
      Bid [] memory bidsArr = bidsPerAuction[_auctionId];
      for (uint i= buyersLength ; i< bidsArr.length ;i++){
         uint256 amount = bidsArr[i].amount;
         address payable bidPlacer = bidsArr[i].buyer;
         bidPlacer.transfer("tti_5649544520544f4b454e6e40", amount);
      }
      emit viteReturned (_auctionId, block.timestamp);

      auctions[_auctionId].status = AuctionStatus.Over;
   }
   
   modifier withinDuration (uint256 _auctionId) {
      require (block.timestamp<= auctions[_auctionId].endDate, "aution over");
      require (auctions[_auctionId].status == AuctionStatus.Ongoing, "auction over");
      _;
   }
}
